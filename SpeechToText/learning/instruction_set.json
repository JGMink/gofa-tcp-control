{
  "_meta": {
    "version": "3.0",
    "architecture": "von Neumann layered ISA",
    "description": "Hierarchical instruction set for ABB GoFa sandwich-assembly robot. Primitives are atomic hardware calls. Composites are stored programs built from primitives. Learned composites are LLM-generated programs built from composites only. The LLM never calls primitives directly.",
    "tiers": {
      "0_primitives": "Atomic hardware operations. Fixed. LLM never calls these directly.",
      "1_composites": "Stored programs written by developers. Built from primitives. LLM calls these.",
      "2_learned": "Programs generated by the LLM at runtime. Built from composites only. Accumulated over sessions."
    },
    "condition_layer": "Pre/post conditions are evaluated by the executor against live state (tcp_commands.json state block + scene_context state). They are NOT instructions — they are guards on instruction execution.",
    "assembly_zone_note": "The assembly_fixture is a passive alignment zone. The robot places items and the fixture remembers nothing — Python tracks the stack order in assembly_stack. The robot does not need to know where items are spatially within the fixture; it always approaches from the same XYZ and the height offset is computed from stack_height.",
    "speed_note": "Speed is persistent state. set_speed sets a mode that applies to all subsequent moves until changed. The motion smoothing multiplier is passed to Unity/RobotStudio per command.",
    "bounds_note": "TCP workspace bounds are a best-effort pre-check in Python. Primary joint/TCP enforcement is handled by RobotStudio RAPID at the hardware level.",
    "backburner": {
      "arc_curve_motion": "move_relative currently only supports cardinal directions (right/left/up/down/forward/backward). Future: irregular, smoothed, or arced motion paths via waypoint interpolation or RAPID MoveC calls. Deferred — needs Unity/RobotStudio motion planner support.",
      "multi_broadcast": "Broadcasting a single instruction to all active zones simultaneously (e.g. 'put bread on both stacks') requires a zone-loop execution mode. Deferred — current executor processes one zone at a time.",
      "partial_undo": "Removing a specific item from mid-stack (e.g. 'take the tomato off') requires the executor to track exact item positions and pick from a non-top position. Deferred — current model only supports top-of-stack pick.",
      "feedback_channel": "User-facing feedback (TTS or text) for impossible commands, unknown items, or very-low-confidence outputs. Partially scaffolded via user_feedback field in interpreter result. Full integration with speech output or UI notification pending."
    }
  },

  "primitives": {
    "_note": "LLM-invisible. Executor calls only. Do not expose in get_llm_context().",

    "move_to": {
      "description": "Move TCP to a named location's absolute XYZ position.",
      "parameters": {
        "location": "string — must exist in scene_context.locations"
      },
      "preconditions": [],
      "example": "move_to(\"bread_slot\")",
      "llm_visible": false
    },

    "move_relative": {
      "description": "Move TCP relative to current position along one cardinal axis. Use for spatial nudges: 'move right', 'shift up a bit', 'go forward'. For diagonal movement chain two calls (e.g. right then forward). NOT for switching assembly zones — use set_active_zone for that.",
      "parameters": {
        "direction": "string — one of: right, left, up, down, forward, backward",
        "distance": "float — distance in cm. Use 1.0 for 'a little/a bit', 3.0–5.0 for 'a lot/far'. Default 1.0."
      },
      "preconditions": [
        "resulting position must be within workspace_bounds (soft check — RobotStudio enforces hard limit)"
      ],
      "defaults": {
        "distance": "motion_params.defaults.move_distance_cm"
      },
      "example": "move_relative(\"right\", 1.0)",
      "llm_visible": true
    },

    "gripper_set": {
      "description": "Set gripper to a named profile. Profile resolves to a position in meters from scene_context.gripper_profiles.",
      "parameters": {
        "profile": "string — one of: open, close_object, full_close"
      },
      "profiles": {
        "open":         "Fully open (travel position). Safe for arm movement between locations.",
        "close_object": "Closed on standard tile. All tiles same size so this is a fixed value.",
        "full_close":   "0.0m — fully closed. Reserved for calibration. Not used in normal operation."
      },
      "preconditions": [
        "close_object: holding must be null (cannot grip if already holding)",
        "open: always safe — no-op if already open"
      ],
      "example": "gripper_set(\"close_object\")",
      "llm_visible": false
    },

    "wait": {
      "description": "Pause execution for a fixed duration. Use for dramatic effect, pacing, or 'hold there for a second'.",
      "parameters": {
        "seconds": "float — wall time to wait. Default 0.5s."
      },
      "defaults": {
        "seconds": 0.5
      },
      "example": "wait(1.0)",
      "llm_visible": true
    },

    "set_speed": {
      "description": "Set persistent speed multiplier for all subsequent move commands. Remains active until changed.",
      "parameters": {
        "level": "string — one of: slow, normal, fast. Aliases resolved before this call — executor only receives canonical level."
      },
      "defaults": {
        "level": "normal"
      },
      "example": "set_speed(\"slow\")",
      "llm_visible": false
    }
  },

  "composites": {
    "_note": "LLM-visible. Each is a stored program of primitives. Parameters use {name} substitution. The LLM calls these by name with actual values — no placeholders in generated output.",

    "pick_up": {
      "description": "Pick up a named ingredient tile from its slot. Gripper opens for safe approach, closes on tile, lifts clear. Fails if already holding something.",
      "parameters": {
        "item": "string — ingredient name. Must exist in scene_context.items. Resolves to {item}_slot location."
      },
      "sequence": [
        {"instruction": "gripper_set",    "params": {"profile": "open"}},
        {"instruction": "move_to",        "params": {"location": "{item}_slot"}},
        {"instruction": "gripper_set",    "params": {"profile": "close_object"}},
        {"instruction": "move_relative",  "params": {"direction": "up", "distance": "motion_params.defaults.lift_clearance_cm"}}
      ],
      "preconditions": [
        "holding must be null"
      ],
      "postconditions": [
        "holding = {item}",
        "gripper = close_object"
      ],
      "llm_visible": true,
      "example": "pick_up(\"cheese\")"
    },

    "place_at": {
      "description": "Place the currently held item at a named location. Lowers to drop height, releases, retracts. Does NOT account for assembly stack height — use add_layer for the assembly_fixture.",
      "parameters": {
        "location": "string — must exist in scene_context.locations"
      },
      "sequence": [
        {"instruction": "move_to",        "params": {"location": "{location}"}},
        {"instruction": "move_relative",  "params": {"direction": "down", "distance": "motion_params.defaults.drop_approach_cm"}},
        {"instruction": "gripper_set",    "params": {"profile": "open"}},
        {"instruction": "move_relative",  "params": {"direction": "up",  "distance": "motion_params.defaults.lift_clearance_cm"}}
      ],
      "preconditions": [
        "holding must not be null"
      ],
      "postconditions": [
        "holding = null",
        "gripper = open"
      ],
      "llm_visible": true,
      "example": "place_at(\"bread_slot\")"
    },

    "return_to_slot": {
      "description": "Return the currently held item back to its ingredient slot. Use to undo a pick_up or cancel mid-sequence. Equivalent to place_at({item}_slot) but infers the slot from what is currently held.",
      "parameters": {},
      "sequence": [
        {"instruction": "place_at", "params": {"location": "{holding}_slot"}}
      ],
      "preconditions": [
        "holding must not be null"
      ],
      "postconditions": [
        "holding = null",
        "gripper = open"
      ],
      "llm_visible": true,
      "example": "return_to_slot()"
    },

    "transfer": {
      "description": "Pick up a named item from its slot and place it at a destination. Combines pick_up and place_at. Do NOT use for assembly_fixture — use add_layer instead.",
      "parameters": {
        "item":        "string — ingredient name",
        "destination": "string — named location (not assembly_fixture)"
      },
      "sequence": [
        {"instruction": "pick_up",  "params": {"item": "{item}"}},
        {"instruction": "place_at", "params": {"location": "{destination}"}}
      ],
      "preconditions": [
        "holding must be null",
        "destination must not be assembly_fixture — use add_layer for that"
      ],
      "postconditions": [
        "holding = null"
      ],
      "llm_visible": true,
      "example": "transfer(\"cheese\", \"bread_slot\")"
    },

    "add_layer": {
      "description": "Pick up a named ingredient and add it to the assembly stack. Automatically calculates drop height based on current stack_height (each tile = tile_height_cm). Increments stack_height and appends item to assembly_stack after placing. Always use this — never place_at or transfer — when adding to the assembly_fixture.",
      "parameters": {
        "item": "string — ingredient name. Must exist in scene_context.items."
      },
      "sequence": [
        {"instruction": "pick_up", "params": {"item": "{item}"}},
        {"note": "Executor computes actual drop distance: drop_approach_cm - (stack_height * tile_height_cm), clamped to min_lower_cm"},
        {"instruction": "move_to",       "params": {"location": "assembly_fixture"}},
        {"instruction": "move_relative", "params": {"direction": "down", "distance": "COMPUTED_stack_aware_drop"}},
        {"instruction": "gripper_set",   "params": {"profile": "open"}},
        {"instruction": "move_relative", "params": {"direction": "up", "distance": "motion_params.defaults.lift_clearance_cm"}}
      ],
      "runtime": true,
      "preconditions": [
        "holding must be null",
        "item must exist in scene_context.items",
        "assembly_stack_height must be less than max_stack_height"
      ],
      "postconditions": [
        "assembly_stack.append({item})",
        "assembly_stack_height += 1",
        "holding = null",
        "gripper = open"
      ],
      "llm_visible": true,
      "example": "add_layer(\"lettuce\")"
    },

    "set_active_zone": {
      "description": "Switch the active assembly zone. All subsequent add_layer calls will target this zone. Required before stacking in a non-default zone. Use before building in assembly_left or assembly_right.",
      "parameters": {
        "zone": "string — one of: assembly_fixture, assembly_left, assembly_right, assembly_center (assembly_center is an alias for assembly_fixture)"
      },
      "sequence": [],
      "runtime": true,
      "runtime_note": "Executor updates scene_context.state.active_zone. No robot motion involved — purely a state switch. Subsequent add_layer calls read active_zone to determine where to place.",
      "preconditions": [
        "zone must be one of the known assembly zones",
        "holding must be null (don't switch zones while gripping)"
      ],
      "postconditions": [
        "state.active_zone = {zone}"
      ],
      "llm_visible": true,
      "example": "set_active_zone(\"assembly_left\")"
    },

    "return_to_stack": {
      "description": "Take the currently held item and return it to its ingredient slot. Used to undo or abort mid-assembly. Not the same as clear_assembly — only affects the one item currently held. If not holding anything, this is a no-op — executor skips silently.",
      "parameters": {},
      "sequence": [
        {"instruction": "return_to_slot", "params": {}}
      ],
      "preconditions": [
        "holding must not be null — if holding IS null, this is a no-op (executor skips, no error)"
      ],
      "postconditions": [
        "holding = null",
        "gripper = open"
      ],
      "llm_visible": true,
      "example": "return_to_stack()"
    },

    "clear_assembly": {
      "description": "Remove all items from the assembly_fixture and return each to its ingredient slot. Works top-to-bottom through assembly_stack. No-op if assembly is already empty. Use to cancel or restart a build.",
      "parameters": {},
      "sequence": [],
      "runtime": true,
      "runtime_note": "Executor dynamically generates sequence by iterating assembly_stack in reverse. For each item: pick from fixture at correct height, return_to_slot. Decrements stack_height and pops assembly_stack at each step.",
      "preconditions": [
        "holding must be null (caller must return_to_stack first if holding something)"
      ],
      "postconditions": [
        "assembly_stack = []",
        "assembly_stack_height = 0",
        "holding = null",
        "gripper = open"
      ],
      "llm_visible": true,
      "example": "clear_assembly()"
    },

    "go_home": {
      "description": "Return arm to home position with gripper open. Safe resting state.",
      "parameters": {},
      "sequence": [
        {"instruction": "gripper_set", "params": {"profile": "open"}},
        {"instruction": "move_to",     "params": {"location": "home"}}
      ],
      "preconditions": [],
      "postconditions": [
        "current_position = home",
        "gripper = open"
      ],
      "llm_visible": true,
      "example": "go_home()"
    },

    "adjust_speed": {
      "description": "Set robot speed using a natural language word. Maps aliases to canonical levels (slow/normal/fast). Speed is persistent — remains active until changed again.",
      "parameters": {
        "modifier": "string — any alias from scene_context.motion_params.speed_profiles aliases, or canonical slow/normal/fast"
      },
      "sequence": [
        {"note": "Executor resolves modifier through speed alias map, then calls set_speed(canonical_level)"},
        {"instruction": "set_speed", "params": {"level": "COMPUTED_canonical_speed"}}
      ],
      "runtime": true,
      "preconditions": [],
      "postconditions": [
        "speed = resolved canonical level"
      ],
      "llm_visible": true,
      "example": "adjust_speed(\"careful\")"
    }
  },

  "learned_composites": {
    "_note": "Generated by LLM at runtime. Each is a named sequence of composites only — no raw primitives. Accumulated across sessions. Shown to LLM as names-only in context; full sequences injected only when the command references that composite by name or recipe."
  },

  "rules": {
    "_note": "Enforced by the executor before and after every instruction. Not instructions themselves — these are guards. Violations return a structured error and halt the sequence.",

    "pre_execution": [
      {
        "id": "no_double_grip",
        "description": "Cannot close gripper on an object if already holding something.",
        "condition": "gripper_set(close_object) AND holding IS NOT null",
        "action": "reject",
        "message": "Already holding {holding} — release before picking up."
      },
      {
        "id": "must_hold_to_place",
        "description": "Cannot place if not holding anything. Exception: return_to_stack is a no-op when holding IS null — skip silently rather than rejecting.",
        "condition": "place_at AND holding IS null",
        "action": "reject",
        "message": "Not holding anything — nothing to place."
      },
      {
        "id": "stack_full",
        "description": "Cannot add a layer if stack is at max height.",
        "condition": "add_layer AND assembly_stack_height >= max_stack_height",
        "action": "reject",
        "message": "Assembly stack is full ({assembly_stack_height}/{max_stack_height} layers)."
      },
      {
        "id": "unknown_item",
        "description": "Item must exist in scene_context.items.",
        "condition": "pick_up OR add_layer AND item NOT IN scene_context.items",
        "action": "reject",
        "message": "Unknown item '{item}'. Available: {scene_context.items.keys}"
      },
      {
        "id": "unknown_location",
        "description": "Location must exist in scene_context.locations.",
        "condition": "move_to AND location NOT IN scene_context.locations",
        "action": "reject",
        "message": "Unknown location '{location}'. Available: {scene_context.locations.keys}"
      },
      {
        "id": "tcp_bounds",
        "description": "Resulting TCP position must be within workspace_bounds. Soft check — RobotStudio enforces hard limit.",
        "condition": "move_relative AND resulting_position OUTSIDE workspace_bounds",
        "action": "clamp",
        "message": "Move would exceed workspace bounds — clamped to boundary."
      },
      {
        "id": "clear_hands_before_clear",
        "description": "Must not be holding anything before clear_assembly.",
        "condition": "clear_assembly AND holding IS NOT null",
        "action": "reject",
        "message": "Holding {holding} — call return_to_stack first before clearing assembly."
      }
    ],

    "post_execution": [
      {
        "id": "state_sync",
        "description": "After every primitive, write current position and gripper state to tcp_commands.json command block."
      },
      {
        "id": "stack_sync",
        "description": "After add_layer or clear_assembly, write updated assembly_stack and assembly_stack_height to scene_context.json."
      }
    ]
  }
}
